/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/2788c8ff-181d-492b-b3bb-f66f8c82862e 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String fermentationEnd;
  String processStage;
  float coldCrashTime;
  float diacetylRestTime;
  float diacetylThreshVal;
  float hopDropTime;
  float maxPres;
  float maxTemp;
  float readingDensity;
  float readingPh;
  float readingPressure;
  float readingTemp;
  float setValueDensity;
  float setValuePres;
  float setValueTemp;
  float tempColdCrash;
  float tempDiacetylRest;
  float tempFermentation;
  float timeLeft;
  bool autoHopDrop;
  bool hopperCO2Purge;
  bool processNextStage;
  bool processPause;
  bool processStart;
  bool processStop;
  bool sendEmail;
  bool surpassedMaxPres;
  bool surpassedMaxTemp;
  bool systemStatus;
  bool valveHopper;
  bool valveProduct;
  bool valveWaste;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/
//Includes
#include "thingProperties.h"



//Density Sensor
#include <Arduino.h>
#include "soc/rtc.h"
#include "HX711.h"
#define calibration_factor -6900.0 //This value is obtained using the SparkFun_HX711_Calibration sketch
const int LOADCELL_DOUT_PIN = 18;
const int LOADCELL_SCK_PIN = 40;

HX711 scale;



//Function Prototypes
void surpassedMax(float maxAllowedValue, float value);
void readPressure();
bool valveControl(bool openOrClosed, int valvePin);
//void systemStatusChecker();
void checkStage();
void setDiacetylStageTimer(unsigned long currentTime);
void setColdCrashStageTimer(unsigned long currentTime);
void baseSolenoidOutCheck(unsigned long currentTime, bool threshold);
void baseSolenoidInCheck(unsigned long currentTime, bool threshold);
bool checkUpperSetPresSurpassed(float upperSetPres);
bool checkLowerSetPresSurpassed(float lowerSetPres);
void coldCrashStageControl(unsigned long currentTime);
void diacetylStageControl(unsigned long currentTime);
void hopperCO2PurgeControl(unsigned long currentTime);
void hopperControl(unsigned long currentTime);
void autoHopDropControl(unsigned long currentTime);
void timeLeftCheck(unsigned long currentTime);
void diacetylEndOfFermentation(unsigned long currentTime);
void readPh();


//Temperature Probe items, from
//Rui Santos, https://randomnerdtutorials.com
#include <OneWire.h>
#include <DallasTemperature.h>
// Data wire is conntec to the Arduino digital pin 4
#define ONE_WIRE_BUS 3
// Setup a oneWire instance to communicate with any OneWire devices
OneWire oneWire(ONE_WIRE_BUS);
// Pass our oneWire reference to Dallas Temperature sensor 
DallasTemperature sensors(&oneWire);


//Pressure Probe items
//from Ovens Garage: Pressure Sensor - Arduino
const int PressurePin = 4;
const float pressureZero = 0.5; //analog reading of pressure transducer at 0psi
const float pressureMax = 4.5; //analog reading of pressure transducer at 150psi
const int pressureTransducerMaxPSI = 30;
float pressureValue = 0;


//pin setup
//ball valves / connect to cloud
int Hopper = 39;
int Product = 38; 
int Waste = 37;
//solenoid
int baseSolenoidOutPin = 36;
int baseSolenoidInPin = 35;
int hopSolenoidOutPin = 34;
int hopSolenoidInPin = 33;
//Sensors
//  Temperature = 3;
//  PressurePin = 4;
int PH_PIN = 5;
//CHILLER_PIN = 7
//PUMP_PIN = 8
//CLCK 40
//DOUT 18

//Solenoid Check Times
unsigned long prevTime_BaseSolenoidOutClose = millis();
unsigned long prevTime_BaseSolenoidOutOpen = millis();
unsigned long prevTime_BaseSolenoidInClose = millis();
unsigned long prevTime_BaseSolenoidInOpen = millis();
//Density Reading Times
unsigned long prevTime_Density = millis();
//Stage Start Times
unsigned long diacetylStartTime = 0;
unsigned long coldCrashStartTime = 0;
unsigned long hopDropStartTime = 0;
//Changing interval Times
unsigned long interval_DiacetylRest;
unsigned long interval_ColdCrash;
unsigned long interval_AutoHopDrop;
//Set Time Intervals
long interval_OneSecond = 1000;
int interval_FiveSeconds = 5000;
int interval_FifteenSeconds = 15000;
int interval_TenSeconds = 10000;
int interval_TwentySeconds = 20000;

//Cold Crash and Diacetyl Timing bools (if they are finished and when the timer should start)
bool coldCrashReady = false;
bool diacetylReady = false;
bool changedToDiacetyl = false;
bool changedToColdCrash = false;

//Hopper Purge
bool hopperCO2PurgeInProgress = false;
bool hopPurgeIntermittentWaiting = false;
int hopPurgeStage = 0;
unsigned long hopPurgeStageTime = 0;

//Hopper process
unsigned long hopDropStageTime;
bool valveHopperOffline = false;
bool hopperOpenInProgress = false;
int hopDropStage = 0;
bool hopDropIntermittentWaiting = false;

//Auto hopper variables
unsigned long autoHopDropControlTimer;
bool waitingForAutoHopDrop = false;
bool changedToFermentation = false;
bool autoHopDropFirstWait = false;

//Solenoid Valve Variables
bool baseSolenoidOut = false;
bool baseSolenoidIn = false;
bool hopSolenoidOut = false;
bool hopSolenoidIn = false;

//values for end of fermentation diacetyl mode
int densitySlopeCount = 0;
int slopeSigns[100];
int positiveSlopeCount;
float densitySlopeSign;
float lastDensity;
bool atLeast100Densities = false;
bool diacetylFermentationFinished = false;



//Temperature Control Constants
// chiller and pump declarations
float tempDif = 0;

unsigned long previous_chiller_Millis = 0;  // Variable to store the last time the compressor was on
const long chiller_off_time = 420000;       // Interval at which to wait before turning chiller back on again (7 min = 420000ms)
const long chiller_on_time = 1200000;      // Interval at which to wait before turning chiller off (20 mins = 1 200 000ms)

unsigned long previous_pump_Millis = 0; // variable to store the last time the pump was on
long pump_on_time = 60000; // for intermittent pumping, how long the pump is on
long pump_off_time = 60000; // for intermittent pumping, how long the pump is off

int chiller_flag = 0;
int pump_flag=0; // both things should start off
bool justTurnedOn = true;

unsigned long current_chiller_Millis;
unsigned long current_pump_Millis;

const int CHILLER_PIN = 7;
const int PUMP_PIN = 8;

unsigned long temperatureControlErrorTime;




void setup() {
  // Initialize serial with computer and wait for port to open
  Serial.begin(9600);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  //The following allows you to obtain more information
  //about the state of network and IoT Cloud connection and errors
  //the higher number the more granular information youâ€™ll get.
  //The default is 0 (only errors). Maximum is 4
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  // Define Valve Pins with user input
  pinMode(Hopper, OUTPUT);
  pinMode(Product, OUTPUT);
  pinMode(Waste, OUTPUT);
  //Define Solenoid Valve Pins
  pinMode(baseSolenoidOutPin, OUTPUT);
  pinMode(baseSolenoidInPin, OUTPUT);
  pinMode(hopSolenoidOutPin, OUTPUT);
  pinMode(hopSolenoidInPin, OUTPUT);
  pinMode(PUMP_PIN, OUTPUT);
  pinMode(CHILLER_PIN, OUTPUT);

  //Density Sensor
  rtc_cpu_freq_config_t config;
  rtc_clk_cpu_freq_get_config(&config);
  //rtc_clk_cpu_freq_to_config(RTC_CPU_FREQ_80M, &config);
  rtc_clk_cpu_freq_set_config_fast(&config);
  scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);
  scale.set_scale(calibration_factor);  
}


void loop() {
  //ESP32 time since startup
  unsigned long currentTime = millis();
  
  //Change Stage Set Interval Times
  if (processStage != "diacetyl"){
    interval_DiacetylRest = diacetylRestTime * 3600000;
  }
  if (processStage != "coldCrash"){
    interval_ColdCrash = coldCrashTime * 3600000;
  }
  if (processStage != "fermentation"){
    interval_AutoHopDrop = hopDropTime * 3600000;
  }

  //Declaring Manual Valve Variables (not initialised because the loop function loops)
  bool hopperCheck;
  bool wasteCheck;
  bool productCheck;
  
  //General Valve Bool for if any valves are open
  bool valveOpen;

  //Upper and lower bounds around the Set Pressure
  float upperSetPres = setValuePres + 1;
  float lowerSetPres = setValuePres - 1;
  //Check if those bounds are surpassed
  bool upperSetPresSurpassed = checkUpperSetPresSurpassed(upperSetPres);
  bool lowerSetPresSurpassed = checkLowerSetPresSurpassed(lowerSetPres);

  //Set Diacetyl Stage Timer
  setDiacetylStageTimer(currentTime);
  //Set Cold Crash Stage Timer
  setColdCrashStageTimer(currentTime);
  //Set Fermentation Stage Timer

  //Change to done if Cold Crash time is reached
  coldCrashStageControl(currentTime);
  //Change to done if Diacetyl time is reached
  diacetylStageControl(currentTime);
  //changed to done if dyacetyl fermentation is reached in end of fermentation mode
  diacetylEndOfFermentation(currentTime);
  //Check the stage
  checkStage();

  //Controlling Hop Solenoids and checking if open          NOT DONE
  autoHopDropControl(currentTime);
  hopperControl(currentTime);
  hopperCO2PurgeControl(currentTime);
  
  //Update Arduino Values
  ArduinoCloud.update();

  //to automatically reconnect if wifi is lost
  WiFi.setAutoReconnect(true);
  WiFi.persistent(true);

  //Controlling Valves and checking if open
  hopperCheck = valveControl(valveHopperOffline, Hopper);
  productCheck = valveControl(valveProduct, Product);
  wasteCheck = valveControl(valveWaste, Waste);

  //Checking if Base Solenoids should be open
  baseSolenoidOutCheck(currentTime, upperSetPresSurpassed);
  baseSolenoidInCheck(currentTime, lowerSetPresSurpassed);

  //opening or closing solenoid valves
  valveControl(baseSolenoidOut, baseSolenoidOutPin);
  valveControl(baseSolenoidIn, baseSolenoidInPin);
  valveControl(hopSolenoidOut, hopSolenoidOutPin);
  valveControl(hopSolenoidIn, hopSolenoidInPin);

  //Checking if any valves are open
  if (hopperCheck || productCheck || wasteCheck || baseSolenoidOut || baseSolenoidIn || hopSolenoidOut || hopSolenoidIn || hopperOpenInProgress){
    valveOpen = true;
  } else {
    valveOpen = false;
  }

  //Temperature Readings
  sensors.requestTemperatures();
  if (processPause == false & valveOpen == false){
    readingTemp = sensors.getTempCByIndex(0);
  }

  //Pressure Readings
  if (processPause == false & valveOpen == false){
    readPressure();
  }

  //pH Readings
  if (processPause == false & valveOpen == false){
    readPh();
  }



  //Density Readings
  if (processPause == false & valveOpen == false){
    if (scale.is_ready()) {  
      long reading = scale.get_units(10);
      Serial.print("Result: ");
      Serial.println(reading);
      readingDensity = reading;
    } else {
      Serial.println("HX711 not found.");
    }
  }



  //check time left
  timeLeftCheck(currentTime);

  //Surpassed Max Safety Values Check             MIGHT NOT NEED IN THE END
    //Meant to notify user if the system is broken, with unreasonable temperature or pressure
  surpassedMax(maxTemp, readingTemp);
  surpassedMax(maxPres, readingPressure);

  //Update system status              MIGHT NOT NEED IN THE END
    ////Meant to notify user if the system is broken, with unreasonable temperature or pressure
  //systemStatusChecker();

  Serial.println("");



  //Temperature Control
  current_chiller_Millis = millis();  // Get the current time
  current_pump_Millis = millis();

  controlChillerSystem();

  temperatureControlErrorPrintings(currentTime); 
}



//Temperature Control Functions
// chiller functions
// function to control the chiller system
void controlChillerSystem(void){
  tempDif = readingTemp-setValueTemp;
  if (tempDif <= 0){
    turn_pump_off();
    Serial.println("Pump is off");
    turn_chiller_off();
  } else if ( 0 < tempDif && tempDif <= 10){
    Serial.println("Pump on time is " + String(pump_on_time));
    pump_cycle();
    chiller_cycle();
  } else if (tempDif >= 10){
    turn_pump_on();
    Serial.println("Pump is constant ON");
    chiller_cycle();
  }
}

//function to cycle the compressor and fan, 20 mins ON, 7 mins OFF (better for compressor to not be on cts for a long period of time)
void chiller_cycle() {
  if (justTurnedOn == true){
    turn_chiller_on();
    justTurnedOn=false; 
  }
  if (chiller_flag == 0) {
    if (current_chiller_Millis - previous_chiller_Millis >= chiller_off_time) {
      turn_chiller_on();
    }
  } 
  else {
    if (current_chiller_Millis - previous_chiller_Millis >= chiller_on_time) {
      turn_chiller_off();
    }
  }
}

// pump Proportional control function
float pump_cycle_length(void){
  if (tempDif >= 0){
  pump_on_time = 30000 * tempDif; // add 0.5 min of on time per 1 deg temp change
  return pump_on_time;
  }
}


// function to turn the pump on and off according to the ON/OFF times dictated by the proportional control function
void pump_cycle() {
  pump_cycle_length();
  if (pump_flag == 0) {
    if (current_pump_Millis - previous_pump_Millis >= pump_off_time) {
      turn_pump_on();
    }
  } 
  else {
    if (current_pump_Millis - previous_pump_Millis >= pump_on_time) {
      turn_pump_off();
    }
  }
}

void turn_pump_on() {
  digitalWrite(PUMP_PIN, HIGH);
  pump_flag = 1;
  previous_pump_Millis = millis();
}

void turn_pump_off() {
  digitalWrite(PUMP_PIN, LOW);
  pump_flag = 0;
  previous_pump_Millis = millis();
}

void turn_chiller_on() {
  digitalWrite(CHILLER_PIN, HIGH);
  chiller_flag = 1;
  previous_chiller_Millis = millis();
}

void turn_chiller_off() {
  digitalWrite(CHILLER_PIN, LOW);
  chiller_flag = 0;
  previous_chiller_Millis = millis();
}



void temperatureControlErrorPrintings(unsigned long currentTime){
  if (currentTime - temperatureControlErrorTime > interval_FiveSeconds){
    Serial.println("temperature control things: ");
    
    if (pump_flag == 1){
      Serial.println("Pump is on");
    } else {
      Serial.println("Pump is off");
    }
    
    if (chiller_flag == 1){
      Serial.println("chiller is on");
    } else {
      Serial.println("chiller is off");
    }

    Serial.println("Temperature Difference is: " + String(tempDif));

    temperatureControlErrorTime = currentTime;
  }
}





//Checks if any max allowed values were passed
  //MIGHT NOT NEED IN THE END
void surpassedMax(float maxAllowedValue, float value){
  if (value > maxAllowedValue){
    if (value == readingPressure){
      surpassedMaxPres = true;
    } else if (value == readingTemp){
      surpassedMaxTemp = true;
    }
  } else {
    if (value == readingPressure){
      surpassedMaxPres = false;
    } else if (value == readingTemp){
      surpassedMaxTemp = false;
    }
  }
}
//at 0 is 910
//at 5 is 1800
//at 10 is 2930
//at 15 is 4120
//at 20 is 5200
//at 25 is 6100
//Read the Pressure
void readPressure(){
  float voltage = analogRead(PressurePin);
  Serial.print("Pressure voltage read is: " + String(voltage));
  readingPressure = ((0.004678)*voltage) -3.918;
}

//Open or closes valves
bool valveControl(bool openOrClosed, int valvePin){
  bool valveOpenCheck;
  
  if (openOrClosed == true){
    digitalWrite(valvePin, HIGH);
    valveOpenCheck = true;
  }
  if (openOrClosed == false){
    digitalWrite(valvePin, LOW);
    valveOpenCheck = false;
  }

  return valveOpenCheck;
}


/*
//MIGHT NOT NEED IN THE END
//Meant to notify user if the system is broken, with unreasonable temperature or pressure
void systemStatusChecker(){
  if(surpassedMaxPres == true || surpassedMaxTemp == true){
    systemStatus = false;
  } else {
    systemStatus = true;
  }
  
  if (systemStatus == false){
    sendEmail = true;
  } else {
    sendEmail = false;
  }
}
*/

//Check the current stage
void checkStage(){
  //The rest stage is "noBatch", so go here if nothing else is working
  if (processStage != "fermentation" & processStage != "diacetyl" & processStage != "coldCrash" & processStage != "done"){
    processStage = "noBatch";
    setValueTemp = tempColdCrash;
  }

  //Regular Logic between stages
  //If currently in noBatch and process is started, go to fermentation
  if (processStage == "noBatch" & processStart){
    processStage = "fermentation";
    setValueTemp = tempFermentation;
    Serial.println("switched from noBatch to fermentation after process start");
  //If in fermentation and density is less than set density + treshold, go to diacetyl
    //and reset diacetyl check values
  } else if (processStage == "fermentation" & readingDensity < (setValueDensity + diacetylThreshVal)){
    processStage = "diacetyl";
    changedToFermentation = false;
    diacetylFermentationFinished = false;
    diacetylReady = false;
    setValueTemp = tempDiacetylRest;
    Serial.println("switched from fermentation to diacetyl since density was below value+threshold");
  //If in diacetly and untilComplete fermentation stage, wait until fermentation is finished and diacetyl timer ends 
    //and reset coldCrash check values
  } else if (processStage == "diacetyl" & fermentationEnd == "untilComplete" & diacetylFermentationFinished == true & diacetylReady){
    processStage = "coldCrash";
    coldCrashReady = false;
    setValueTemp = tempColdCrash;
    Serial.println("switched from diacetyl to cold crash cause time was ready, and set to fermentationEnd");
  //If in diacetyl and untilSetDensity stage, wait until density is below set density and diacetyl timer ends
    //and reset coldCrash check values
  } else if (processStage == "diacetyl" & fermentationEnd == "untilSetDensity" & readingDensity < setValueDensity & diacetylReady){ //include the timer
    processStage = "coldCrash";
    coldCrashReady = false;
    setValueTemp = tempColdCrash;
    Serial.println("switched from diacetyl to cold crash cause time was ready and density below set value");
  //If in coldCrash and coldCrash time has finished, go to done stage
  } else if (processStage == "coldCrash" & coldCrashReady == true){
    processStage = "done";
    setValueTemp = tempColdCrash;
    Serial.println("switched from coldcrash to done since coldcrash was ready");
  //If processStop is clicked, go to noBatch
  } else if (processStop){
    processStage = "noBatch";
    setValueTemp = tempColdCrash;
    Serial.println("switched from any stage to noBatch cause stop was pressed");
  }

  //If the "Next Stage" button is pressed, go to next stage and reset any check values
  if (processStage == "noBatch" & processNextStage){
    processStage = "fermentation";
    setValueTemp = tempFermentation;
    processNextStage = false;
    Serial.println("switched from batch to fermentation cause nextstage was pressed");
  } else if (processStage == "fermentation" & processNextStage){
    processStage = "diacetyl";
    diacetylFermentationFinished = false;
    diacetylReady = false;
    setValueTemp = tempDiacetylRest;
    processNextStage = false;
    changedToFermentation = false;
    Serial.println("switched from fermentation to diacetyl cause nextstage was pressed");
  } else if (processStage == "diacetyl" & processNextStage){
    processStage = "coldCrash";
    coldCrashReady = false;
    setValueTemp = tempColdCrash;
    processNextStage = false;
    Serial.println("switched from diacetly to coldcrash cause nextstage was pressed");
  } else if (processStage == "coldCrash" & processNextStage){
    processStage = "done";
    setValueTemp = tempColdCrash;
    processNextStage = false;
    Serial.println("switched from coldcrash to done cause nextstage was pressed");
  } else if (processStage == "done" & processNextStage){
    processStage = "noBatch";
    setValueTemp = tempColdCrash;
    processNextStage = false;
    Serial.println("switched from done to done noBatch cause nextstage was pressed");
  }

  //Reset Values in noBatch
  if (processStage == "done"){
    timeLeft = 0;
  }
}

//Set Diacetyl Stage Timer
void setDiacetylStageTimer(unsigned long currentTime){
  if (processStage == "diacetyl" & changedToDiacetyl == false){
    diacetylStartTime = currentTime;
    changedToDiacetyl = true;
    Serial.println("set diacetyl timer");
  }
  if (processStage == "noBatch"){
    changedToDiacetyl = false;
  }
}

//Set Cold Crash Stage Timer
void setColdCrashStageTimer(unsigned long currentTime){
  if (processStage == "coldCrash" & changedToColdCrash == false){
    coldCrashStartTime = currentTime;
    changedToColdCrash = true;
    Serial.println("set coldcrash timer");
  }
  if (processStage == "noBatch"){
    changedToColdCrash = false;
  }
}

//baseSolenoidOut check loop
  //Close after a second
  //check every 10 seconds if gas needs to be let out
void baseSolenoidOutCheck(unsigned long currentTime, bool threshold){
  //Check every 1 second if valve is open, then close valve
  if (currentTime - prevTime_BaseSolenoidOutClose > interval_OneSecond){
    if (baseSolenoidOut == true){
      baseSolenoidOut = false;
      Serial.println("close base solenoid out");
    }
    prevTime_BaseSolenoidOutClose = currentTime;
  }

  //Check every 10 seconds if upperSetPresSurpassed is true, then open valve
  if (currentTime - prevTime_BaseSolenoidOutOpen > interval_TenSeconds){
    if (threshold == true){
      baseSolenoidOut = true;
      Serial.println("open base solenoid out");
    }
    prevTime_BaseSolenoidOutOpen = currentTime;
  }
}

//baseSolenoidIn check loop
  //close after one second
  //check every 10 seconds if gas needs to be let in
void baseSolenoidInCheck(unsigned long currentTime, bool threshold){
  //Check every 1 second if valve is open, then close valve
  if (currentTime - prevTime_BaseSolenoidInClose > interval_OneSecond){
    if (baseSolenoidIn == true){
      baseSolenoidIn = false;
      Serial.println("close base solenoid in");
    }
    prevTime_BaseSolenoidInClose = currentTime;
  }

  //Check every 10 seconds if minSetPresSurpassed is true, then open valve
  if (currentTime - prevTime_BaseSolenoidInOpen > interval_TenSeconds){
    if (threshold == true){
      baseSolenoidIn = true;
      Serial.println("open base solenoid in");
    }
    prevTime_BaseSolenoidInOpen = currentTime;
  }
}

//check if upper pressure bound is surpassed
bool checkUpperSetPresSurpassed(float upperSetPres){
  if (readingPressure > upperSetPres){
    return true;
  }
  //if not above, it's below or equal and returns false
  return false;
}

//check if lower pressure bound is surpassed
bool checkLowerSetPresSurpassed(float lowerSetPres){
  if (readingPressure < lowerSetPres){
    return true;
  }
  //if not below, it's above or equal and returns false
  return false;
}

//say cold crash is ready if timer is done
void coldCrashStageControl(unsigned long currentTime){
  if(currentTime - coldCrashStartTime > interval_ColdCrash){
    coldCrashReady = true;
  }
}

//say daicetyl is ready if timer is done
void diacetylStageControl(unsigned long currentTime){
  if(currentTime - diacetylStartTime > interval_DiacetylRest){
    diacetylReady = true;
  }
}

void hopperCO2PurgeControl(unsigned long currentTime){
  if (hopperCO2Purge == true & hopperCO2PurgeInProgress == false & hopperOpenInProgress == false){
    hopperCO2PurgeInProgress = true;
    Serial.println("hopper purge process started");
    Serial.println("hopSolenoids opened");
  }

  if (hopperCO2PurgeInProgress == true){
    if (hopPurgeStage == 0){
      hopSolenoidIn = true;
      hopSolenoidOut = true;
      if (hopPurgeIntermittentWaiting == false){
        hopPurgeStageTime = currentTime;
        hopPurgeIntermittentWaiting = true;
      }

      if (currentTime - hopPurgeStageTime > interval_FiveSeconds){
        hopPurgeStage = 1;
        hopPurgeIntermittentWaiting = false;
      }
    }

    if (hopPurgeStage == 1){
      hopSolenoidIn = false;
      hopSolenoidOut = false;
      if (hopPurgeIntermittentWaiting == false){
        hopPurgeStageTime = currentTime;
        hopPurgeIntermittentWaiting = true;
        Serial.println("hopper purge process: solenoids closed");
      }

      if (currentTime - hopDropStageTime > interval_TenSeconds){
        hopPurgeStage = 0;
        hopPurgeIntermittentWaiting = false;
        hopperCO2PurgeInProgress = false;
        Serial.println("hopper purge process: done");
      }
    }
  }
}

//hopper control in a series of timed stages
void hopperControl(unsigned long currentTime){  
  if (valveHopper == true & hopperOpenInProgress == false & hopperCO2PurgeInProgress == false){
    hopperOpenInProgress = true;
    Serial.println("hopper control process started");
  }
  
  if (hopperOpenInProgress == true){
    if (hopDropStage == 0){
      valveHopperOffline = true;
      if (hopDropIntermittentWaiting == false){
        hopDropStageTime = currentTime;
        hopDropIntermittentWaiting = true;
        Serial.println("hopper control process: hopper opened");
      }

      if (currentTime - hopDropStageTime > interval_TwentySeconds){
        hopDropStage = 1;
        hopDropIntermittentWaiting = false;
      }
    }

    if (hopDropStage == 1){
      valveHopperOffline = false;
      if (hopDropIntermittentWaiting == false){
        hopDropStageTime = currentTime;
        hopDropIntermittentWaiting = true;
        Serial.println("hopper control process: hopper closed");
      }

      if (currentTime - hopDropStageTime > interval_TenSeconds){
        hopDropStage = 2;
        hopDropIntermittentWaiting = false;
      }
    }

    if (hopDropStage == 2){
      hopSolenoidOut = true;
      if (hopDropIntermittentWaiting == false){
        hopDropStageTime = currentTime;
        hopDropIntermittentWaiting = true;
        Serial.println("hopper control process: hop solenoid out opened");
      }

      if (currentTime - hopDropStageTime > interval_TenSeconds){
        hopDropStage = 3;
        hopDropIntermittentWaiting = false;
      }
    }

    if (hopDropStage == 3){
      hopSolenoidOut = false;
      if (hopDropIntermittentWaiting == false){
        hopDropStageTime = currentTime;
        hopDropIntermittentWaiting = true;
      }
      

      if (currentTime - hopDropStageTime > interval_TenSeconds){
        hopDropStage = 0;
        hopDropIntermittentWaiting = false;
        hopperOpenInProgress = false;
        Serial.println("hopper control process ended");
      }
    }
  }
}

//Autohopdrop control
void autoHopDropControl(unsigned long currentTime){  
  if (autoHopDrop == true & changedToFermentation == false){
    Serial.println("autohopdrop process started");
    Serial.println("hop in and out solenoids opened");
    hopSolenoidIn = true;
    hopSolenoidOut = true;
    autoHopDropControlTimer = currentTime;
    changedToFermentation = true;
    autoHopDropFirstWait = true;
  }

  if (autoHopDropFirstWait == true & currentTime - autoHopDropControlTimer > interval_TenSeconds){
    hopSolenoidIn = false;
    hopSolenoidOut = false;
    autoHopDropControlTimer = currentTime;
    waitingForAutoHopDrop = false;
    autoHopDropFirstWait = false;
    Serial.println("autohopdrop timer started");
  }

  if (waitingForAutoHopDrop == true & currentTime - autoHopDropControlTimer > interval_AutoHopDrop + 20000){
    valveHopper = true;
    waitingForAutoHopDrop = false;
    Serial.println("autohopdroptimer ended");
  }
}

//checks the time left for the given timer
void timeLeftCheck(unsigned long currentTime){  
  if (processStage == "diacetyl"){
    unsigned long elapsedTime = currentTime - diacetylStartTime;
    if (elapsedTime < interval_DiacetylRest) {
      timeLeft = interval_DiacetylRest - elapsedTime;
    } else {
      timeLeft = 0;
    }
  } else if (processStage == "coldCrash"){
    unsigned long elapsedTime = currentTime - coldCrashStartTime;
    if (elapsedTime < interval_ColdCrash) {
      timeLeft = interval_ColdCrash - elapsedTime;
    } else {
      timeLeft = 0;
    }
  } else {
    timeLeft = 0;
  }

  Serial.print("time left in milliseconds: ");
  Serial.println(timeLeft);
}

//diacetylEndOfFermentation mode checker
  //finds the slope sign between the current and last value every second
  //adds this to an array
  //once all 100 spots are filled, reset the count so spots are filled again
    //and you can now check these slopes
  //if the diacetyl timer is ready and there are 100 slopes in the array
    //if over 45 of these slopes are positive, consider the fermenting to have plateaued
  //then reset all the values
void diacetylEndOfFermentation(unsigned long currentTime){
  if (currentTime - prevTime_Density > interval_OneSecond){
  
    //find slope
    densitySlopeSign = readingDensity - lastDensity;

    slopeSigns[densitySlopeCount] = densitySlopeSign;
  
    densitySlopeCount++;
      
    if (densitySlopeCount > 100){
      //reset count to 0
      densitySlopeCount = 0;
      atLeast100Densities = true; //ENSURE THIS IS RESET
    }

    if (diacetylReady == true){
      if (atLeast100Densities == true & processStage == "diacetyl"){
      //find numbers in array that are positive 
        //if number is above 45, go next stage
        for (int i = 0; i < 100; i++){
          if (slopeSigns[i] > 0) {
            positiveSlopeCount++;
          } else {
            positiveSlopeCount--;
          }
        }

        //reset all values for this stage and go to the next stage
        if (positiveSlopeCount > 45){
          diacetylFermentationFinished = true;
          
          changedToDiacetyl = false;
          atLeast100Densities = false;
          densitySlopeCount = 0;

          for (int i = 0; i < 100; i++){
            slopeSigns[i] = 0;
          }

          
        }
    }

    lastDensity = readingDensity;
    prevTime_Density = currentTime;
    }
    
  }
}

void readPh(){
  float voltage = analogRead(PH_PIN);
  Serial.print(voltage);
  readingPh = ((-3.0/1660.0)*voltage) + 15.6;
}


/*
  Since BoardSwitch is READ_WRITE variable, onBoardSwitchChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onBoardSwitchChange()  {
  // Add your code here to act upon BoardSwitch change
}

/*
  Since DashboardLight is READ_WRITE variable, onDashboardLightChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onDashboardLightChange()  {
  // Add your code here to act upon DashboardLight change
}

/*
  Since MaxPres is READ_WRITE variable, onDashboardLightChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onMaxPresChange()  {
  // Add your code here to act upon SetValuePres change
}

/*
  Since MaxTemp is READ_WRITE variable, onDashboardLightChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onMaxTempChange()  {
  // Add your code here to act upon SetValuePres change
}

/*
  Since SurpassedMaxPres is READ_WRITE variable, onSurpassedMaxPresChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSurpassedMaxPresChange()  {
  // Add your code here to act upon SurpassedMaxPres change
}

/*
  Since SurpassedMaxTemp is READ_WRITE variable, onSurpassedMaxTempChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSurpassedMaxTempChange()  {
  // Add your code here to act upon SurpassedMaxTemp change
}

/*
  Since SetValuePres is READ_WRITE variable, onSetValuePresChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSetValuePresChange()  {
  // Add your code here to act upon SetValuePres change
}

/*
  Since SetValueTemp is READ_WRITE variable, onSetValueTempChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSetValueTempChange()  {
  // Add your code here to act upon SetValueTemp change
}

/*
  Since SystemStatus is READ_WRITE variable, onSystemStatusChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSystemStatusChange()  {
  // Add your code here to act upon SystemStatus change
}

/*
  Since Hopper is READ_WRITE variable, onHopperChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onHopperChange()  {
  // Add your code here to act upon Hopper change
}

/*
  Since ProductValve is READ_WRITE variable, onProductValveChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onProductValveChange()  {
  // Add your code here to act upon ProductValve change
}

/*
  Since HopperValve is READ_WRITE variable, onHopperValveChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onHopperValveChange()  {
  // Add your code here to act upon HopperValve change
}

/*
  Since ValveHopper is READ_WRITE variable, onValveHopperChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onValveHopperChange()  {
  // Add your code here to act upon ValveHopper change
}

/*
  Since ValveProduct is READ_WRITE variable, onValveProductChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onValveProductChange()  {
  // Add your code here to act upon ValveProduct change
}

/*
  Since ValveWaste is READ_WRITE variable, onValveWasteChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onValveWasteChange()  {
  // Add your code here to act upon ValveWaste change
}

/*
  Since SendEmail is READ_WRITE variable, onSendEmailChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSendEmailChange()  {
  // Add your code here to act upon SendEmail change
}

/*
  Since TempFermentation is READ_WRITE variable, onTempFermentationChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onTempFermentationChange()  {
  // Add your code here to act upon TempFermentation change
}

/*
  Since TempColdCrash is READ_WRITE variable, onTempColdCrashChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onTempColdCrashChange()  {
  // Add your code here to act upon TempColdCrash change
}

/*
  Since TempDiacetylRest is READ_WRITE variable, onTempDiacetylRestChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onTempDiacetylRestChange()  {
  // Add your code here to act upon TempDiacetylRest change
}

/*
  Since FermentationEnd is READ_WRITE variable, onFermentationEndChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onFermentationEndChange()  {
  // Add your code here to act upon FermentationEnd change
}

/*
  Since SetValueDensity is READ_WRITE variable, onSetValueDensityChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSetValueDensityChange()  {
  // Add your code here to act upon SetValueDensity change
}

/*
  Since DiacetylRestTime is READ_WRITE variable, onDiacetylRestTimeChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onDiacetylRestTimeChange()  {
  // Add your code here to act upon DiacetylRestTime change
}

/*
  Since DiacetylRestTemp is READ_WRITE variable, onDiacetylRestTempChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onDiacetylRestTempChange()  {
  // Add your code here to act upon DiacetylRestTemp change
}

/*
  Since ColdCrashTime is READ_WRITE variable, onColdCrashTimeChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onColdCrashTimeChange()  {
  // Add your code here to act upon ColdCrashTime change
}

/*
  Since ProcessPause is READ_WRITE variable, onProcessPauseChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onProcessPauseChange()  {
  // Add your code here to act upon ProcessPause change
}

/*
  Since ProcessStart is READ_WRITE variable, onProcessStartChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onProcessStartChange()  {
  // Add your code here to act upon ProcessStart change
}

/*
  Since ProcessStop is READ_WRITE variable, onProcessStopChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onProcessStopChange()  {
  // Add your code here to act upon ProcessStop change
}

/*
  Since DiacetylThreshVal is READ_WRITE variable, onDiacetylThreshValChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onDiacetylThreshValChange()  {
  // Add your code here to act upon DiacetylThreshVal change
}

/*
  Since ProcessNextStage is READ_WRITE variable, onProcessNextStageChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onProcessNextStageChange()  {
  // Add your code here to act upon ProcessNextStage change
}

/*
  Since TimeLeft is READ_WRITE variable, onTimeLeftChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onTimeLeftChange()  {
  // Add your code here to act upon TimeLeft change
}


/*
  Since HopDropTime is READ_WRITE variable, onHopDropTimeChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onHopDropTimeChange()  {
  // Add your code here to act upon HopDropTime change
}

/*
  Since AutoHopDrop is READ_WRITE variable, onAutoHopDropChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onAutoHopDropChange()  {
  // Add your code here to act upon AutoHopDrop change
}

/*
  Since HopperCO2Purge is READ_WRITE variable, onHopperCO2PurgeChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onHopperCO2PurgeChange()  {
  // Add your code here to act upon HopperCO2Purge change
}
